# 39. 组合总和

![Untitled](39%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20ed3246af7b5a4578a8a9b5398e9a7afb/Untitled.png)

![Untitled](39%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20ed3246af7b5a4578a8a9b5398e9a7afb/Untitled%201.png)

![Untitled](39%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20ed3246af7b5a4578a8a9b5398e9a7afb/Untitled%202.png)

![Untitled](39%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20ed3246af7b5a4578a8a9b5398e9a7afb/Untitled%203.png)

![Untitled](39%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20ed3246af7b5a4578a8a9b5398e9a7afb/Untitled%204.png)

# 问题

❌错误

```jsx
var backtraking = function (candidates, target, start) {
        for (let i = start; i < candidates.length; i++) {
            if (sum > target) {
                return;
            }
            if (sum == target) {
                res.push([...path]);
                return;
            }
            path.push(candidates[i]);
            sum += candidates[i];
						//这里如果继续调入start，还是传入的0，应该传入i
            backtraking(candidates, target, **start**);
            sum -= candidates[i];
            path.pop()
        }
    }
```

✅正确

![Untitled](39%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20ed3246af7b5a4578a8a9b5398e9a7afb/Untitled%205.png)

```jsx
var backtraking = function (candidates, target, start) {
        if (sum == target) {
            res.push([...path]);
            return;
        }
        for (let i = start; i < candidates.length; i++) {
				//for (let i = start; i < candidates.length && **sum + candidates[i] <= target**; i++) 也可以直接写入for条件里
            if (sum + candidates[i] > target) break; //这里这样写是因为已经对数组进行排序了，后面的元素就再试了，直接停止循环
            path.push(candidates[i]);
            sum += candidates[i];
            backtraking(candidates, target, i);
            sum -= candidates[i];
            path.pop()
        }
    }
```

# 答案

```jsx
var combinationSum = function (candidates, target) {
    const res = [];
    candidates.sort((a, b) => (a - b));
    let sum = 0;
    const path = [];
    var backtraking = function (candidates, target, start) {
        if (sum == target) {
            res.push([...path]);
            return;
        }
        for (let i = start; i < candidates.length && sum + candidates[i] <= target; i++) {
            path.push(candidates[i]);
            sum += candidates[i]; 
            backtraking(candidates, target, i);
            sum -= candidates[i];
            path.pop()
        }
    }

    backtraking(candidates, target, 0);
    return res;
};
```