# 17. 电话号码的字母组合⭐

# 解法1

![Untitled](17%20%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%E2%AD%90%20073ffa549f104110bee8e8136cad644c/Untitled.png)

第3层，就是将path.length === digits.length，将结果加入res中，return结束递归

```jsx
var letterCombinations = function (digits) {
    const map = ["", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"];

    if (!digits) return [];  //若digits = "" Boolean("")为false
    if (digits.length === 1) return map[digits].split(""); //[...map[digits]]

    //对res，path初始化
    const res = [], path = [];

    function backtracking(digits, a) {
        if (path.length === digits.length) {
            res.push(path.join(""));
            return;
        }
				//map -> "abc"...
        for (const v of map[digits[a]]) {
						//v = "a"...
            path.push(v);
            backtracking(digits, a + 1);
            path.pop();
        }

    }

    backtracking(digits, 0);
    return res;
};
```

**path:**

![Untitled](17%20%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%E2%AD%90%20073ffa549f104110bee8e8136cad644c/Untitled%201.png)

**path.join(””)**

![Untitled](17%20%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%E2%AD%90%20073ffa549f104110bee8e8136cad644c/Untitled%202.png)

**v of map[n[a]] ： v of “abc”…**

![Untitled](17%20%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%E2%AD%90%20073ffa549f104110bee8e8136cad644c/Untitled%203.png)

![Untitled](17%20%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%E2%AD%90%20073ffa549f104110bee8e8136cad644c/Untitled%204.png)

# 困惑版

![Untitled](17%20%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%E2%AD%90%20073ffa549f104110bee8e8136cad644c/Untitled%205.png)

```jsx
var letterCombinations = function (digits) {
    const k = digits.length;
    const map = ["", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"];
    if (!k) return [];
    if (k === 1) return map[digits].split("");

    const res = [], path = [];
    backtracking(digits, k, 0);
    return res;

    function backtracking(n, k, a) {
        if (path.length === k) {
            res.push(path.join(""));
            return;
        }
        for (const v of map[n[a]]) {
            console.log(n,a,map[n[a]])
          
            path.push(v);
            backtracking(n, k, a + 1);
            path.pop();
        }

    }
};
```